# -*- coding: utf-8 -*-
"""JAMES_CHEN_LinearAlgebra_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XWamepqU_EfY3pdkVfSJt7VL4wd-JMmc

Please follow the instructions carefully. Write all your code in a `Code` cell, and your explanations in a `Markdown` cell. Make sure that your code compiles correctly either by selecting a given cell and clicking the `Run` button, or by hitting `shift`+`enter` or `shift`+`return`.

### 1. Import `numpy`, `numpy.linalg`, `matplotlib.pyplot`, and `pandas`. Use the appropriate aliases when importing these modules.
"""

# Commented out IPython magic to ensure Python compatibility.
# code for question 1
import numpy as np
import numpy.linalg as la
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline

"""### 2. Load the data from the file named `data_stock_returns.csv` into a `DatFrame` called `returns`. The file `data_stock_returns.csv` contains daily returns of a number of stocks selected from the S&P 500 universe. The rows of the csv file represent the returns over a number of days, and the columns represent individual stocks labeled by their NYSE ticker symbol, e.g., Apple stock is labeled `AAPL`."""

# code for question 2
from google.colab import files
uploaded = files.upload()
returns = pd.read_csv('data_stock_returns.csv')

"""### 3. View the `head` of the `returns` `DataFrame`"""

# code for question 3
returns.head()

"""### 4. View the `tail` of the `returns` `DataFrame`"""

# code for question 4
returns.tail()

"""### 5. How many stocks are in this `DataFrame`?"""

# code for question 5
a = returns.columns[1:] #every column except the first one (dates)
print(len(a))

"""**ANSWER FOR QUESTION 5**: double click on this cell to write your answer
<br>
488 stocks are in this DataFrame

### 6. Over how many days are these stock returns reported?
"""

# code for question 6
returns.describe()

"""**ANSWER FOR QUESTION 6**: double click on this cell to write your answer
<br>
These stocks are reported for 252 days.

### 7. Extract the returns of the Amazon stock only, which has a ticker symbol `AMZN`. Save it in a `Series` called `amzn_returns`.
"""

# code for question 7
amzn_returns = returns['AMZN']
amzn_returns

"""### 8. Plot the Amazon stock returns extracted in the above cell. """

# code for question 8
plt.plot(amzn_returns)
plt.title("Amazon Stock Returns vs. Day")
plt.xlabel("Day")
plt.ylabel("Stock Returns")

"""### 9. Plot the cumulative sum of the Amazon stock returns using the method `.cumsum()` which acts directly on the `amzn_returns` `Series`."""

# code for question 9
plt.plot(amzn_returns.cumsum())
plt.title("Cumulative sum of Amazon stock returns")
plt.xlabel("Day")
plt.ylabel("Cumulative returns")

# the module below will allow us to perform linear regression
import statsmodels.api as sm

"""The function `lin_reg(x,y)` given below performs ordinary least squares (OLS) linear regression using `sm.OLS` from the `statsmodels.api` module.

The code enclosed in `''' '''` is the docstring of the function `lin_reg`.

`x` in the `lin_reg` function is a matrix that contains the regressors, and `y` represents the vector containing the dependent variable. Note that `x` might contain one vector or multiple vectors. In the case that `x` contains one vector $x$, the regression gives:

$$ y = \beta_0 + \beta_1 x $$

In the case that `x` contains multiple vectors $x_1, \dots, x_k$, the regression becomes:

$$ y = \beta_0 + \beta_1 x_1 + \dots + \beta_k x_k$$

The $\beta$'s are the regression coefficients obtained using least squares. Note that `sm.add_constant` is used in the function below to make `x` look like the matrix $A$ we use in least squares, whose first column contains all ones.
"""

def lin_reg(x, y):
    '''
    ordinary linear regression using least-squares
    
    Parameters
    ----------  
    x: regressors (numpy array)
    y: dependent variable (numpy array)
    
    Returns
    -------
    coefficients: regression coefficients (pandas Series)
    residuals: regression residuals (numpy array)
    r_squared: correlation coefficient (float)
    
    '''
    x = sm.add_constant(x)
    model = sm.OLS(y, x).fit()
    coefficients = model.params
    residuals = model.resid
    r_squared = model.rsquared
    return coefficients, residuals, r_squared

"""### 10. Let's try to use the above function. Extract (as numpy array) the stock returns of:

- Apple (ticker symbol `AAPL`) and call it `aapl`
- Intel (ticker symbol `INTC`) and call it `intc`
- Microsoft (ticker symbol `MSFT`) and call it `msft`
- IBM (ticker symbol `IBM`) and call it `ibm`

### Let `y` be the Apple stock returns, and `x` be the Intel stock returns. Use the `lin_reg` function defined above to find $y=\beta_0 + \beta_1 x$. 
"""

# code for question 10
aapl = returns['AAPL']
intc = returns['INTC']
msft = returns['MSFT']
ibm = returns['IBM']
print(lin_reg(intc, aapl))

"""Answer: So the least squares model is $y = 0.001956 + 0.5635263x$, where x are the Intel stock returns and y are the predicted Apple stock returns.

### 11. Plot the cumulative sum of the Apple returns prediction from least squares on top of the actual Apple returns. How well do the Intel stock returns describe the Apple stock returns?
"""

# code for question 11
plt.plot(aapl.cumsum())
x = np.arange(0,252,1)
y = 0.001956 + 0.5635263*intc
plt.plot(x, y.cumsum())
plt.title("Cumulative Apple returns and Cumulative sum of Apple returns prediction")
plt.legend(['Cumulative Apple returns', 'Cumulative sum of Apple returns prediction'])
plt.xlabel("Day")
plt.ylabel("Cumulative returns")

"""Answer to: How well do the Intel stock returns describe the Apple stock returns?
<br>
The Intel stock returns describe the Apple stock returns moderately well. The R-squared value of 0.305 is low, so the two variables are not perfectly correlated. However, the prediction still captures peaks and dips in the Apple stock. Most notably, the prediction and the actual returns both seem to peak between Day 60 and 80, and then they both dip between Day 80 and Day 110 (rough estimates based on what I can see).

### 12. Now, let `y` be the Apple stock returns, and `x` be the Intel, Microsoft, and IBM stock returns. Use the `lin_reg` function defined above to find $y=\beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_3$, where $x_1$ represents Intel returns, $x_2$ represents Microsoft returns, and $x_3$ represents IBM returns.
"""

# code for question 12
X = pd.DataFrame({'INTC': intc,
                   'MSFT': msft,
                   'IBM': ibm,
                    })
print(lin_reg(X, aapl))

"""Answer: The least squares model is $y=0.001116 + 0.284141 x_1+ 0.543723 x_2 + 0.150586 x_3$, where $x_1$ represents Intel's stock returns, $x_2$ represents Microsoft's returns, $x_3$ represents IBM's returns, and $y$ represents Apple's predicted returns.  

---

### 13. Plot the cumulative sum of the Apple returns prediction from least squares on top of the cumulative sum of actual Apple returns. How well do the Intel, Microsoft, and IBM stock returns describe the Apple stock returns?
"""

# code for question 13
plt.plot(aapl.cumsum())
x = np.arange(0,252,1)
y = 0.001116 + 0.284141*intc + 0.543723*msft + 0.150586*ibm
plt.plot(x, y.cumsum())
plt.title("Cumulative Apple returns and Cumulative sum of Apple returns prediction")
plt.legend(['Cumulative Apple returns', 'Cumulative sum of Apple returns prediction'])
plt.xlabel("Day")
plt.ylabel("Cumulative returns")

"""Answer to: How well do the Intel, Microsoft, and IBM stock returns describe the Apple stock returns?
<br>
The Intel, Microsoft, and IBM stock returns together describe the Apple stock returns very well. This model has an R-squared of 0.47, which is much higher than the previous model's R-squared. However the model still fails to capture all the changes in the Apple stock, and it tends to overestimate. Maybe if we added even more companies, the model would be even better.

The file `SPY.csv` contains the prices of SPDR S&P 500 ETF Trust. This Exchange Traded Fund (ETF) contains a collection of assets currently present in the S&P 500 index. 

### 14. Load `SPY.csv` into a DataFrame called `spy_prices` using the `read_csv` method in `pandas`. Make sure to make the 'Date' column to be your index column. To do that, read the docstring for `read_csv`.
"""

# code for question 14
from google.colab import files
uploaded = files.upload()
spy_prices = pd.read_csv('SPY.csv', index_col = 'Date')

"""### 15. Once you have downloaded the file into the `DataFrame`, observe all the available prices and dates. Show the head of the `DataFrame`, and then answer the following questions:

(a) Which prices are reported?

(b) From which date to which date are these prices reported?
"""

# code for question 15
display(spy_prices.head())
display(spy_prices.tail())

"""**ANSWER FOR QUESTION 15**: double click on this cell to write your answer
<br>
a) The prices reported are: the high price, low price, opening price, closing price, and adjusted closing price. It also displays the volume of trades.
<br>
b) The dates reported start on 1/2/2015 and end on 6/1/2020

### 16. Retain only the Adjusted Close price in the `spy_prices` `DataFrame`. Call the resulting `Series` `spy_adjclose`.
"""

# code for question 16
spy_adjclose = spy_prices['Adj Close']
spy_adjclose

"""### 17. Now, using the `pct_change` method in `pandas`, compute the returns on the Adjusted Close prices of SPY, and only retain the returns from '2019-01-01' to '2020-01-01'. Call the `Series` obtained `spy_returns`."""

# code for question 17
spy_returns = spy_adjclose.pct_change().loc['2019-01-01':'2020-01-01']
spy_returns

"""### 18. Perform SVD on `returns` data that contain assets from the S&P 500. Retain the left singular vector corresponding to the largest singular value and call is `u_sigma1`."""

# code for question 18
returns_without_date = returns.loc[:,'ATVI':]
U, Sigma, V = la.svd(returns_without_date)
u_sigma1 = U[:, 0]
u_sigma1

"""### 19. `u_sigma1` is thought to track the market. To test that, we will perform a regression of `spy_returns` against this first left singular vector by letting `y=spy_returns` and `x=u_sigma1` and computing

### $$ y = \beta_0 + \beta_1 x$$
### using least squares regression.
"""

# code for question 19
x=u_sigma1
y=spy_returns
lin_reg(x, y)

"""$y = 0.000346 - 0.118992 x$

### 20. Plot the cumulative sum of the result from the regression on top of the cumulative sum of `spy_returns`. What do you notice?
"""

# code for question 20
plt.plot(spy_returns.cumsum())
Y = 0.000346-0.118992*x
plt.plot(Y.cumsum())
plt.title("Cumulative sum of spy_returns and Cumulative sum of result from regression")
plt.legend(['Cumulative sum of spy_returns', 'Cumulative sum of regression result'])
plt.xlabel("Date")
plt.ylabel("Cumulative returns")

"""**ANSWER FOR QUESTION 20**: double click on this cell to write your answer
<br>
The result from the regression is a very good predictor of spy_returns. The R-squared is .90, which is much higher than any other model we made in this project. Even though we only used one left singular vector, the model is still very accurate.

Congratulations! You have just implemented your first statistical 
Capital Asset Pricing Model (CAPM) to the S&P 500 market.
"""